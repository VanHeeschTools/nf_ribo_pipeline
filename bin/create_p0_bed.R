#!/usr/bin/env Rscript

# Load libraries
suppressPackageStartupMessages({
    library(tidyverse)
    library(data.table)
    library(GenomicFeatures)
    library(Biostrings)
    library(GenomicRanges)
    library(seqinr)
    library(stringdist)
})

# Obtain input arguments
args <- commandArgs(trailingOnly=TRUE)

gtf <- args[1]            # Input gtf file
is_orfcaller <- args[2]   # Value to show if input gtf is from an ORFcaller
gtf_seq <- args[3]        # Amino acid sequences of all CDSs
bsgenome_path <- args[4]  # Path to custom BSgenome package

## Declare functions

#' Load ORFcaller GTF File and turn into dataframe
#'
#' Imports an ORFcaller-generated GTF file and extracts CDS coordinates
#' per ORF. Each ORF is summarized into a single row with its chromosome,
#' strand, and comma-separated lists of start and end positions.
#'
#' @param gtf_file_path Path to the GTF file generated by ORFcaller.
#'
#' @return A data frame where each row represents an ORF
load_orfcaller_gtf <- function(gtf_file_path){
    gtf <- rtracklayer::import(gtf_file_path) %>%
        as.data.frame()
    
    # Summarize CDS entries per ORF
    orf_list <- gtf %>%
        dplyr::filter(type == "CDS") %>%                 # Keep only CDS features
        dplyr::group_by(ORF_id) %>%                      # Group by ORF identifier
        dplyr::summarise(
        chr   = unique(as.character(seqnames))[1],  # Extract chromosome
        strand = unique(as.character(strand))[1],        # Extract strand
        starts = paste(sort(start), collapse = ","),     # Combine sorted starts
        ends   = paste(sort(end), collapse = ",")        # Combine sorted ends
        ) %>%
        dplyr::ungroup() %>%
        as.data.frame()
    
    return(orf_list)
}

#' Obtain ORFcaller P0 Sites
#'
#' Expands CDS exon coordinates for each ORF into single-nucleotide positions
#' and determines the codon frame per nucleotide based on strand orientation.
#' Only nucleotides in frame 0 (`p0`)  are retained.
#'
#' @param gtf A data frame containing predicted ORF CDS
#' 
#' @return A dataframe with one row per P0 nucleotide
obtain_orfcaller_p0 <- function(gtf){

    # Create bed file filtered for p0 sites
    orf_list_bed <- gtf %>%
        # Select only relevant columns
        dplyr::select(ORF_id, chr, strand, starts, ends) %>%
        
        # Split comma-separated coordinates into separate rows
        tidyr::separate_rows(starts, ends, sep = ",") %>%
        
        # Convert to numeric
        dplyr::mutate(
        starts = as.numeric(starts),
        ends   = as.numeric(ends)
        ) %>%
        
        # Expand each exon into one row per nucleotide position
        dplyr::rowwise() %>%
        dplyr::mutate(pos = list(seq(starts, ends))) %>%
        tidyr::unnest(pos) %>%
        dplyr::ungroup() %>%
        
        # Order nucleotides by genomic coordinate per ORF
        dplyr::arrange(ORF_id, pos) %>%
        dplyr::group_by(ORF_id) %>%
        
        # Determine codon frame and position within ORF (strand-specific)
        dplyr::mutate(
        frame = dplyr::case_when(
            strand == "+" ~ (dplyr::row_number() - 1) %% 3,
            strand == "-" ~ (max(dplyr::row_number()) - dplyr::row_number()) %% 3
        ),
        nt_position = ifelse(
            strand == "+",
            dplyr::row_number(),
            max(dplyr::row_number()) - dplyr::row_number() + 1
        ),
        frame = paste0("p", frame),
        pos_2 = pos) %>%
        dplyr::ungroup() %>%
        
        # Keep only nucleotides in frame 0 (first base of each codon)
        #dplyr::filter(frame == "p0") %>%
        # Subtract 1 from pos to create proper bed file format
        mutate(pos = pos - 1) %>% 
        
        # Final output
        dplyr::select(chr, pos, pos_2, ORF_id, frame, strand, nt_position)

    return(orf_list_bed)
}

#' Find and load BSgenome library
#'
#' Searches given path for BSgenome libary, will load the library if found
#' @param bsgenome_path Path to directory that should contain the library
#' 
#' @return loaded BSgenome library with name genome
load_bsgenome_library <- function(bsgenome_path){
    # Add the directory to the library search path
    paths <- c(bsgenome_path, .libPaths())
    .libPaths(paths)
    
    # Automatically detect the BSgenome package name in that directory
    bsgenome_dirs <- list.dirs(bsgenome_path, full.names = FALSE, 
                                recursive = FALSE)
    bsgenome_name <- bsgenome_dirs[grepl("^BSgenome\\.", bsgenome_dirs)]
    # Function to extract the BSgenome object from the package namespace
    load_bsgenome <- function(pkg) {
        ns <- asNamespace(pkg)
        bsgenome_obj <- Filter(function(x) inherits(get(x, envir = ns), "BSgenome"),
                        ls(ns))
        get(bsgenome_obj[[1]], envir = ns)
    }
    
    # Load the genome object
    genome <- load_bsgenome(bsgenome_name)
    return(genome)
}

    #' Translate nucleotides into amino acid
    #'
    #' Function to translate nucleotides into amino acid. Frame indicates 
    #' how many nucleotides should be skipped before beginning translation.
    #'  
    #' @param seq sequence to be translated
    #' @param frame frame in which seq should be translated
    #' 
    #' @return translated protein sequence
    translate_seq <- function(seq, frame = 0) {

    if (length(seq) < (3 + frame)) return("")
    prot_seq <- seqinr::translate(seq, frame = frame) %>% 
        paste0(collapse = "") %>% 
        str_replace("[*]$", "")
    return(prot_seq)
}

#' Read protein fasta file
#'
#' @param gtf_seq path to protein sequence file
#' 
#' @return translated protein sequence

read_protein_fasta <- function(gtf_seq){
    # Read protein sequences
    protein_seq <- read.fasta(gtf_seq, as.string = TRUE) %>% 
        enframe("tx_id", "prot_seq") %>% 
        mutate(prot_seq = toupper(prot_seq) %>% str_replace("^X", ""),
            tx_id = str_extract(tx_id, "ENST\\d+[.]\\d+")) %>% 
        as.data.table()
    return(protein_seq)
}

get_transcript_cds <- function(genome, cds_list){
    # Get CDS nt sequences based on GTF genomic coordinates
    cds_seqs <- extractTranscriptSeqs(genome, cds_list)
    cds_seq_dt <- 
        data.table(seq=as.character(cds_seqs), tx_id=names(cds_seqs),
                len = width(cds_seqs)
        )[, c("len_3", "has_stop", "has_start") := 
            list(len %% 3 == 0, str_ends(seq, "TGA|TAG|TAA"),
                str_starts(seq, "ATG"))]
}

#' Determine correct CDS frame
#'
#' @param genome BSgenome library
#' @param cds_list GRanges object contating transcript and their CDS
#' 
#' @return data.frame of CDS and the frame which they are in

obtain_cds_info <- function(genome, cds_list){

    # Split GTF CDS in 'correct' ones (first codon is start, last one is start,
    #  length divisable by three) and 'incorrect ones'
    cds_seq_dt_correct <- cds_seq_dt[len_3 & has_stop & has_start,
                                    .(tx_id, frame = 0)]
    
    # The incorrect sequences are translated in all three frames
    cds_seq_dt_incorrect <- 
        cds_seq_dt[!(len_3 & has_stop & has_start)
        ][, seq_array := str_split(tolower(seq), "")
        ][, c("frame0", "frame1", "frame2") := 
            list(map(seq_array, function(x) translate_seq(x, 0)),
                map(seq_array, function(x) translate_seq(x, 1)),
                map(seq_array, function(x) translate_seq(x, 2)))
        ][, c("frame0", "frame1", "frame2") := 
            list(as.character(frame0), as.character(frame1), 
                as.character(frame2))]
    
    # Merge translated sequences with protein sequences, decide frame
    # based on string distance â‰¤10%. If the protein sequence is not provided 
    # the frame cannot be determined.
    cds_seq_dt_incorrect_merged <-
        protein_seq[cds_seq_dt_incorrect, on = "tx_id"
        ][, c("dist0", "dist1", "dist2") := 
            list(stringdist(prot_seq, frame0, method = "lv") /
                nchar(prot_seq),
                stringdist(prot_seq, frame1, method = "lv") /
                nchar(prot_seq),
                stringdist(prot_seq, frame2, method = "lv") /
                nchar(prot_seq))
        ][, frame := case_when(
        dist0 <= .1 ~ 0,
        dist1 <= .1 ~ 1,
        dist2 <= .1 ~ 2,
        .default = -1)
        ][, .(tx_id, frame)]
    
    # Merge incorrect and correct CDS, exclude CDSs for which frame is still 
    #  undetermined
    cds_frame <- 
        rbindlist(list(cds_seq_dt_correct, cds_seq_dt_incorrect_merged)
        )[frame != -1]
    
    return(cds_frame)
}


#' Determine Correct CDS Coordinates
#'
#' Adjusts the CDS coordinates of transcripts so that:
#'   1. All CDS rows start at a codon boundary according to the determined 
#'      reading frame.
#'   2. The total length of the CDS is divisible by 3, removing incomplete 
#'      codons at the ends.
#'
#' @param cds_list A `GRangeslist` object containing the CDS coordinates 
#'        of transcripts.
#' @param cds_frame A data.frame with columns `tx_id` and `frame`, giving the 
#'        frame offset (0, 1, 2) for each transcript.
#'
#' @return A data.frame with adjusted CDS coordinates.
determine_correct_cds_coords <- function(cds_list, cds_frame) {

    cds_id_gene <- as.data.frame(cds_list) %>%
        # Clean chromosome names and select relevant columns
        mutate(chr = str_remove(seqnames, "^chr")) %>%
        dplyr::select(tx_id = group_name, chr, strand, start, end, width) %>%
        inner_join(cds_frame, by = "tx_id") %>% # Join with CDS frame info
        group_by(tx_id) %>%
        
        # Sort plus strand on start order and minus strand in reverse start order
        arrange(tx_id, if_else(strand == "+", start, -start)) %>%
        
        ## Adjust start (+ strand) and end (- strand) based on frame
        mutate(
        cum_wid = cumsum(width),
        to_delete = frame - lag(cum_wid, default = 0),
        start = if_else(strand == "+" & to_delete > 0, start + to_delete, start),
        end   = if_else(strand == "-" & to_delete > 0, end - to_delete, end)
        ) %>%
        
        ## Filter out invalid exons after frame adjustment 
        filter(start <= end) %>%
        # Sort minus strand on end order and plus strand in reverse end order
        arrange(tx_id, if_else(strand == "-", start, -start)) %>%
        
        ## Remove partial codons (ensure total CDS length divisible by 3)
        mutate(
        width = end - start + 1,
        end_remove = sum(width) %% 3,
        cum_wid = cumsum(width),
        to_delete = end_remove - lag(cum_wid, default = 0),
        end   = if_else(strand == "+" & to_delete > 0, end - to_delete, end),
        start = if_else(strand == "-" & to_delete > 0, start + to_delete, start)
        ) %>%
        filter(start <= end) %>%
        arrange(tx_id, start) %>% 
        
        ## Finalize widths and create unique CDS ID
        mutate(
        width = end - start + 1,
        cds_id = sprintf(
            "P1_%s:%d_%d:%s:%d:%d",
            chr, min(start), max(end), strand, n(), sum(width)
        )
        ) %>%
        # Only keep relevant rows
        dplyr::select(tx_id, chr, strand, start, end, width)
        
    return(cds_id_gene)
}

#' Create p0 bed file for reference CDS sequences
#'
#' @param cds_ids_gene A data.frame with adjusted CDS coordinates.
#'
#' @return A data.frame with bed file rows containing p0 sites
create_reference_bed_file <- function(cds_ids_gene){

    # Create bed file for CDS sequences
    cds_list_bed <- cds_id_gene %>% 
        rowwise() %>%
        mutate(start_to_end = list(seq(start, end))) %>%
        unnest(start_to_end) %>% 
        arrange(start_to_end) %>% 
        group_by(tx_id) %>% 
        mutate(frame = case_when(
            strand == "+" ~ (row_number() - 1) %% 3,
            strand == "-" ~ (max(row_number()) - row_number()) %% 3),
            frame = paste0("p", frame),
            start_to_end2 = start_to_end,
            nt_position = ifelse(strand == "+", row_number(), 
                            max(row_number()) - row_number() + 1)) %>% 
        ungroup() %>% 
        #filter(frame == "p0") %>% 
        # Subtract 1 from start_to_end to create proper bed format
        mutate(start_to_end = start_to_end - 1) %>% 
        dplyr::select(chr, start_to_end, start_to_end2, tx_id, frame, strand,
                    nt_position) 
}

### Run functions

# Run p0 file creator on either ORFcaller gtf or reference gtf
if (is_orfcaller == "ORF_id"){
    # Load ORF gtf file
    orf_list <- load_orfcaller_gtf(gtf)
    # Obtain p0 sites of ORFcallers
    orf_list_bed <- obtain_orfcaller_p0(orf_list)
    # Write to bed(like) file
    write_tsv(orf_list_bed, paste0(tools::file_path_sans_ext(basename(gtf)),
        "_p0.bed"), col_names = FALSE)
} else{
    
    # Step 1: Load required input
    # Create TxDb for querying transcripts and CDSs
    txdb <- txdbmaker::makeTxDbFromGFF(gtf, format = "gtf")
    transcript_list <- exonsBy(txdb, by = "tx", use.names = TRUE)
    cds_list <- cdsBy(txdb, by = "tx", use.names = TRUE) 
    
    genome <- load_bsgenome_library(bsgenome_path)  # Load bsgenome package
    protein_seq <- read_protein_fasta(gtf_seq)      # Read protein fasta file
    
    # Obtain transcript CDS sequences
    cds_seq_dt <- get_transcript_cds(genome, cds_list)
    
    # Step 2: Determine correct start frame for CDS
    cds_frame <- obtain_cds_info(genome, cds_list)
    
    # Step 3: Determine correct CDS start and end coords
    cds_id_gene <- determine_correct_cds_coords(cds_list, cds_frame)

    # Step 4: Create p0 bed file for reference CDS
    cds_list_bed <- create_reference_bed_file(cds_ids_gene)

    # Step 5: Save output
    saveRDS(cds_id_gene, paste0(tools::file_path_sans_ext(
        basename(gtf)),"_correct_cds.rds"))
        
    write_tsv(cds_list_bed, file = paste0(tools::file_path_sans_ext(
        basename(gtf)),"_p0.bed"), col_names = FALSE)  
}


